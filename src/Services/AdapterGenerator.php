<?php
namespace App\Services;

class AdapterGenerator
{
    protected string $adaptersNamespace = 'App\AutoGenerated';
    protected string $adaptersDirectory;

    public function __construct()
    {
        $this->adaptersDirectory = __DIR__ . '/../AutoGenerated';
    }

    public function generate(string $interfaceName): string
    {
        $reflection = new \ReflectionClass($interfaceName);
        
        if (!$reflection->isInterface()) {
            throw new \InvalidArgumentException("{$interfaceName} must be an interface");
        }

        $adapterName = $this->adaptersNamespace . '\\' . $reflection->getShortName() . 'Adapter';
        
        if (class_exists($adapterName)) {
            return $adapterName;
        }

        $methodsCode = [];
        foreach ($reflection->getMethods() as $method) {
            $methodsCode[] = $this->generateMethodCode($method);
        }

        $classCode = $this->generateClassCode($adapterName, $interfaceName, $methodsCode);

        // Создаем директорию, если нужно
        if (!file_exists($this->adaptersDirectory)) {
            mkdir($this->adaptersDirectory, 0777, true);
        }

        // Сохраняем класс в файл
        $filename = $this->adaptersDirectory . '/' . $reflection->getShortName() . 'Adapter.php';
        file_put_contents($filename, "<?php\n\nnamespace {$this->adaptersNamespace};\n\n{$classCode}");

        // Подключаем файл
        require_once $filename;

        return $adapterName;
    }

    protected function generateClassCode(string $className, string $interfaceName, array $methods): string
    {
        $shortClassName = substr(strrchr($className, '\\'), 1);
        $shortInterfaceName = substr(strrchr($interfaceName, '\\'), 1);
        $methodsCode = implode("\n\n", $methods);
        
        return <<<CODE
class $shortClassName implements \\$interfaceName
{
    protected \$obj;

    public function __construct(\$obj)
    {
        \$this->obj = \$obj;
    }

$methodsCode
}
CODE;
    }

    protected function generateMethodCode(\ReflectionMethod $method): string
    {
        $methodName = $method->getName();
        $parameters = [];
        $paramsForIoC = [];
        
        foreach ($method->getParameters() as $param) {
            $paramStr = '';
            if ($param->hasType()) {
                $paramStr .= $param->getType() . ' ';
            }
            $paramStr .= '$' . $param->getName();
            
            if ($param->isDefaultValueAvailable()) {
                $paramStr .= ' = ' . var_export($param->getDefaultValue(), true);
            }
            
            $parameters[] = $paramStr;
            $paramsForIoC[] = '$' . $param->getName();
        }
        
        $parametersStr = implode(', ', $parameters);
        $paramsForIoCStr = $paramsForIoC ? ', ' . implode(', ', $paramsForIoC) : '';
        
        $returnType = $method->getReturnType();
        $returnStr = $returnType ? ': ' . $returnType->getName() : '';
        
        if ($returnType && $returnType->getName() === 'void') {
            return <<<METHOD
    public function $methodName($parametersStr)$returnStr
    {
        \App\IoC\IoC::Resolve("{$method->getDeclaringClass()->getName()}:$methodName", \$this->obj$paramsForIoCStr)->execute();
    }
METHOD;
        } else {
            return <<<METHOD
    public function $methodName($parametersStr)$returnStr
    {
        return \App\IoC\IoC::Resolve("{$method->getDeclaringClass()->getName()}:$methodName", \$this->obj$paramsForIoCStr);
    }
METHOD;
        }
    }
}